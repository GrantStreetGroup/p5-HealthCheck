=head1 Writing a HealthCheck::Diagnostic

This document is here to help you write a diagnostic.

=head2 What is a HealthCheck Diagnostic?

A health check diagnostic is a specific task that is focused in one
area of an application's health.
This can mean multiple things, like checking if a file exists or the
app can connect to a database.

In technical terms, a health check diagnostic is a subroutine that
returns a hashref in the
L<Health Check Standard|https://support.grantstreet.com/wiki/display/AC/Health+Check+Standard>
format.

In lay-man's terms, this just mans that a diagnostic must return a hashref
consisting of the C<status> key and some other optional keys.
You may want to add an C<info> message to the diagnostic if you want to
give it a more human-readable description of the test.

Here is an example of a result hashref that could be returned by
a diagnostic:

    {   status => "OK",
        info   => "Connecting to the database",
    }

=head2 Diagnostic methods

The L<HealthCheck::Diagnostic> module provides a base for writing your
own checks with validation of the results as a promise to conform
to the standard.
When you want to create your own diagnostic, you have the option to
override a few different methods.

=head3 new

This is your basic constructor method.
It just returns the blessed object, so you may want to add default
values on the diagnostic instance that is returned.

Set a default label on the diagnostic instance:

    sub new {
        my ($class, %params) = @_;

        return $class->SUPER::new(
            label => 'default_label',
            %params,
        );
    }

We may also want to allow the constructor to take in a hashref, or
an even-sized list of parameters:

    my ($class, @params) = @_;
    my %params = @params == 1 && ( ref $params[0] || '' ) eq 'HASH'
        ? %{ $params[0] } : @params;

=head3 run

This is where you would normally implement the check.
It runs the test and returns the result hashref.
You would most-likely be overriding this method with your actual test
logic.

    sub run { return { status => 'OK' } }

See the note in L</check> regarding throwing exceptions in this method.

=head3 summarize

This performs some extra logic if we want to have sub-tests in our
diagnostic.
This method squashes those C<status> values in the sub-tests and
validates the result hashref meets the specification in the Standard.
If there are values in the result that aren't valid for some reason,
an C<OK> status will get converted to C<UNKNOWN> and the validation
error will get appended to the C<info>.

Here is an example of a C<run> override that uses summarize:

    sub run {
        my $result1 = {
            status => 'OK',
            info   => 'The test passed',
        };
        my $result2 = {
            status => 'CRITICAL',
            info   => 'The test failed',
        };

        return {
            info    => 'Uses summarize',
            results => [ $result1, $result2 ],
        };
    }

This is what the result hashref would look like when the check is run:

    {   status  => 'CRITICAL',
        info    => 'Uses summarize',
        results => [ $result1, $result2 ],
    }

Note that C<summarize> is called by the default C<check> method,
so you will want to take that into account
if you are overriding the C<check> method in any way.

=head3 check

This is the default method that will be called by the HealthCheck.
It ends up calling L</run> and then L</summarize> on the result hashref.
You would want to override this method if you want to roll out your
own custom approach, likely for validation and summarization.

You may want to require certain parameters to be passed to the check.
This type of validation is done as follows:

    sub check {
        my ($self, %params ) = @_;

        croak( "Missing required `file` key" )
            unless $params{file};

        my $res = $self->SUPER::check( %params );
        return $res;
    }

One special note to keep in mind is this method will trap any exceptions
during the call to L</run> and will set the C<status> to C<CRITICAL>
and put the exception message into the C<info> key of the result hashref.

=head2 Writing class checks and instance checks

Now that you know about the methods, you may want to know about the
different ways to create your diagnostic.

In general, it's not terribly difficult most of the time to support both
instance and class based checks so consider using the L</Multi checks> pattern
if e can.

=head3 Instance checks

Instance checks are diagnostics that are designed to be used as an
instance.
This implementation requires you to instantiate the diagnostic with
the parameters being used in the check.

When used on an instance the L</summarize> method will additionally
copy the C<id>, C<label>, and C<tags> from the instance to the C<result>
that is returned if they aren't already included.

Here is an example instance-only implementation module:

    package HealthCheck::Diagnostic::TempCheck;
    use parent 'HealthCheck::Diagnostic';

    sub check_temp { .. } # Returns a hashref using $_[1] as temp value.

    sub run {
        my ($self, %params) = @_;
        return $self->check_temp( $self->{temperature} );
    };

    1;

Here is an example using that module:

    my $diagnostic = HealthCheck::Diagnostic::TempCheck->new(
        temperature => '22',
    );
    $health_check->register( $diagnostic );
    $health_check->check;

If we want to create an instance-only implementation, we may want
to override the C<check> method in our diagnostic module to put that
restriction in-place:

    sub check {
        my ($self, @args ) = @_;
        croak( "check cannot be called as a class method" )
            unless ref $self;
        return $self->SUPER::check( @args );
    }

=head3 Class checks

Class check diagnostics are designed so that the diagnostic does not
need to be an instance.
In that case, we pay special attention to the parameters that are
passed to the C<check> and C<run> methods.

As a benefit to our users, we probably want to disable calling C<new>
or even better, consider supporting L</Multi checks>.

Here is an example of the same diagnostic listed above, but uses a
class implementation:

    package HealthCheck::Diagnostic::TempCheck;
    use parent 'HealthCheck::Diagnostic';

    # Don't allow instantiating an instance
    use Carp;
    sub new { croak(__PACKAGE__ . " does not support being an instance.") }

    sub check_temp { ... } # Returns a hashref using $_[1] as temp value.

    sub run {
        my ($class, %params) = @_;
        return $class->check_temp( $params{temperature} );
    }

    1;

Any parameters passed to the HealthCheck instance's C<check>
are passed the diagnostic's C<check> which in turn passed it to C<run>.
Here is an example using that module in a health-check:

    $health_check->register( 'HealthCheck::Diagnostic::TempCheck' );
    $health_check->check( temperature => 20 );

=head3 Multi checks

It is entirely possible to allow both instance and class checks
in the same module.
We just need to design our diagnostic so that it can handle that:

    package HealthCheck::Diagnostic::TempCheck;
    use parent 'HealthCheck::Diagnostic';

    sub check_temp { ... } # Returns a hashref using $_[1] as temp value.

    sub check {
        my ($self, %params) = @_;
        if ( ref $self ) {
            # Default all instance values as arguments to the `run` method.
            $params{$_} = $self->{$_}
                foreach grep { ! defined $params{$_} } keys %$self;
        }
        return $self->SUPER::check( %params );
    }

    sub run {
        my ($self, %params) = @_;
        return $self->check_temp( $params{temperature} );
    }

    1;

Then, we can use the diagnostic as either an instance or class in
our health-check:

    # Register a class check that uses all the defaults.
    $health_check->register( 'HealthCheck::Diagnostic::TempCheck' );

    # Register an instance check.
    $diagnostic = HealthCheck::Diagnostic::TempCheck->new(
        id          => 'cheese_temp',
        label       => 'Cool enough to age cheese',
        temperature => 12.5,  # gets overridden by the value passed to check
    );
    $health_check->register( $diagnostic );

    # Run the checks, assuming check_temp claims a current temp of 95 degrees
    $health_check->check();

Here are the results from that last C<check> call,
if the class based check had defined a default temperature limit
things may have gone better,
but as it is we don't know what limit you might have wanted to compare.
The second result overrides that status though as

    {   status  => 'CRITICAL',
        results => [
            {
                status => 'UNKNOWN',
                info   => 'The temperature limit is unknown',
            },
            {
                id     => 'cheese_temp',
                label  => 'Cool enough to age cheese',
                status => 'CRITICAL',
                info   => 'The temperature is too hot',
            },
        ],
    }

Now we override the temperature, which is passed to both diagnostics:

    # Run the checks, assuming check_temp claims a current temp of 95 degrees
    $health_check->check( temperature => 100 );

Here are the results from that last C<check> call,
as you notice because we passed in a new temperature limit,
it overrode the limit and says 95 degrees is jut fine for aging cheese,
but we know that's a much better temp for melting it onto noodles!

    {   status  => 'OK',
        results => [
            {
                status => 'OK',
                info   => 'The temperature is just right',
            },
            {
                id     => 'cheese_temp',
                label  => 'Cool enough to age cheese',
                status => 'OK',
                info   => 'The temperature is just right',
            },
        ],
    }

=head2 More in-depth example

In this example, we're going to add a check for a physical system
to make it easier to visualize,
a sensor system that can tell us when we should open or close the window.
What we're going to imagine is that we have three sensors:
inside, outside, and the window status.
The inside sensor can tell us the current temperature,
while the outside sensor can tell us both temperature and whether it is raining.
The window sensor is just a boolean check for whether the window is open.


We might initialize a diagnostic with several different sensors
that let it decide whether our window is in a good position.

    my $diagnostic = HealthCheck::Diagnostic::WindowStatus->new(
        inside  => My::Sensor::Inside->new,
        outside => My::Sensor::Outside->new,
        window  => My::Sensor::Window->new,

        desired_min => 20,
        desired_max => 23,
    );


The implementation for that check might look something like this:

    package HealthCheck::Diagnostic::WindowStatus;
    use parent "HealthCheck::Diagnostic";
    use strict;
    use warnings;

    sub run {
        my ($self) = @_;

        # Gather some data that we can return to be used for graphing
        my @data = (
            {   label => "Inside Temperature",
                value => $self->{inside}->temp,
            },
            {   label => "Outside Temperature",
                value => $self->{outside}->temp,
            },
            {   label => "Currently Raining",
                value => $self->{outside}->is_raining,
            },
            {   label => "Window is Open",
                value => $self->{window}->is_open,
            },
        );

        my %res = ( status = "OK", data = \@data );

        # If it's currently raining, need to close the windows
        if ( $self->{outside}->is_raining ) {
            if ( $self->current_state eq "open" ) {
                $res{status} = "CRITICAL";
                $res{info}   = "Close the window, it's raining!";
            }
            return \%res;
        }

        # Otherwise, see if the state we want matches the current state.
        my $desired_state = $self->desired_state;
        if ( $desired_state ne $self->current_state ) {
            $res{status} = "WARNING";
            $res{info}   = "\u$desired_state the window!";
        }

        return \%res;
    }

    sub current_state { shift->{window}->is_open ? "open" : "close" }

    sub desired_state {
        my ($self) = @_;

        my $inside  = $self->{inside}->temp;
        my $outside = $self->{outside}->temp;

        # If the weather is nice outside, open the window
        if (    $outside >= $self->{desired_min}
            and $outside <= $self->{desired_max} )
        {
            return "open";
        }

        # If the outside temp is in the correct
        # direction of our desired temp, open the window.
        my $cold_inside    = $inside < $self->{desired_min};
        my $hot_inside     = $inside > $self->{desired_max};
        my $warmer_outside = $inside < $outside;
        my $cooler_outside = $inside > $outside;

        if (   ( $cold_inside and $warmer_outside )
            or ( $hot_inside  and $cooler_outside ) )
        {
            return "open";
        }

        return "close";
    }

    1;
