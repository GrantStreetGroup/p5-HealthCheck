=head1 Writing a HealthCheck::Diagnostic

This document is here to help you write a diagnostic.

=head2 What is a HealthCheck Diagnostic?

A health check diagnostic is a specific task that is focused in one
area of an application's health.
This can mean multiple things, like checking if a file exists or the
app can connect to a database.

In technical terms, a health check diagnostic is a subroutine that
returns a hashref in the
L<Health Check Standard|https://support.grantstreet.com/wiki/display/AC/Health+Check+Standard>
format.

In lay-man's terms, this just mans that a diagnostic must return a hashref
soncisting of the C<status> key and some other optional keys.
You may want to add an C<info> message to the diagnostic if you want to
give it a more human-readable description of the test.

Here is an example of a result hashref that could be returned by
a diagnostic:

    {   status => "OK",
        info   => "Connecting to the database",
    }

=head2 Diagnostic methods

The L<HealthCheck::Diagnostic> module provides a base for writing your
own checks with validation of the results as a promise to conform
to the standard.
When you want to create your own diagnostic, you have the option to
override a few different methods.

=head3 new

This is your basic constructor method.
It just returns the blessed object, so you may want to add default
values on the diagnostic instance that is returned.

Set a default label on the diagnostic instance:

    sub new {
        my ($class, %params) = @_;

        return $class->SUPER::new(
            label => 'default_label',
            %params,
        );
    }

You may also want to allow the constructor to take in a hashref, or
an even-sized list of parameters:

    my %params = @params == 1 && ( ref $params[0] || '' ) eq 'HASH'
        ? %{ $params[0] } : @params;

=head3 run

This is your basic check. It runs the test, and returns the result hashref.
You would most-likely be overriding this method with your actual test
logic.

One special note to keep in mind is that any exceptions get trapped in
the C<info> key of the result hashref.

=head3 summarize

This performs some extra logic if you want to have sub-tests in your
diagnostic.
This method merely squashes those C<status> values in the sub-tests and
validates the result hashref for errors.

Here is an example of a C<run> override that utilizes summarize:

    sub run {
        my $test1 = {
            status => 'OK',
            info   => 'The test passed',
        };
        my $test2 = {
            status => 'CRITICAL',
            info   => 'The test failed',
        };

        return {
            info    => 'Uses summarize',
            results => [ $test1, $test2 ],
        };
    }

This is what the result hashref would look like when the check is run:

    {   status  => 'CRITICAL',
        info    => 'Uses summarize',
        results => [ $test1, $test2 ],
    }

Note that C<summarize> is called during the C<check> method, so you may
want to take that into account if you are overriding the C<check> method
in any way.

=head3 check

This is what gets called by the HealthCheck.
It ends up calling C<run> and then C<summarize> on the result hashref.
You would want to override this method if you want to roll out your
own custom approach, likely for validation and summarization.

One special note to keep in mind is that exceptions do not get trapped
in here at all, as opposed to C<run>.

You may want to require certain parameters to be passed to the check.
This type of validation is done as follows:

    sub check {
        my ($self, %params ) = @_;

        croak( "Missing required `file` key" )
            unless $params{file};

        my $res = $self->SUPER::check( %params );
        return $res;
    }

=head2 Writing class checks and instance checks

Now that you know about the methods, you may want to know about the
different ways to create your diagnostic.

=head3 Instance checks

Instance checks are diagnostics that are designed to be used as an
instance.
This implementation requires you to instantiate the diagnostic with
the parameters being used in the check.

Here is an example instance-only implementation module:

    package HealthCheck::Diagnostic::TempCheck;
    use parent 'HealthCheck::Diagnostic';

    sub check_temp { .. } # Returns a hashref using $_[1] as temp value.

    sub run {
        my ($self, %params) = @_;
        return $self->check_temp( $self->{temperature} );
    };

    1;

Here is an example using that module:

    my $diagnostic = HealthCheck::Diagnostic::TempCheck->new(
        temperature => '22',
    );
    $health_check->register( $diagnostic );
    $health_check->check;

If we want to create an instance-only implementation, we may want
to override the C<check> method in our diagnostic module to put that
restriction in-place:

    sub check {
        my ($self, @args ) = @_;
        croak( "check cannot be called as a class method" )
            unless ref $self;
        return $self->SUPER::check( @args );
    }

=head3 Class checks

Class check diagnostics are designed so that the diagnostic does not
need to be an instance.
In that case, we pay special attention to the parameters that are
passed to the C<check> and C<run> methods.

Here is an example of the same diagnostic listed above, but uses a
class implementation:

    package HealthCheck::Diagnostic::TempCheck;
    use parent 'HealthCheck::Diagnostic';

    sub check_temp { ... } # Returns a hashref using $_[1] as temp value.

    sub run {
        my ($self, %params) = @_;
        return $self->check_temp( $params{temperature} );
    }

    1;

Any parameters passed to C<check> are passed to C<run> by default.
Here is an example using that module in a health-check:

    $health_check->register( 'HealthCheck::Diagnostic::TempCheck' );
    $health_check->check( temperature => 20 );

=head3 Multi checks

In some cases where we would want to allow for both an instance and class
check, we can do that.
We just need to define our diagnostic so that it can handle that:

    package HealthCheck::Diagnostic::TempCheck;
    use parent 'HealthCheck::Diagnostic';

    sub check_temp { ... } # Returns a hashref using $_[1] as temp value.

    sub check {
        my ($self, %params) = @_;
        if ( ref $self ) {
            # Copy over instance values as arguments to the `run` method.
            params{$_} = $self->{$_}
                foreach grep { ! defined $params{$_} } keys %$self;
        }
        return $self->SUPER::check( %params );
    }

    sub run {
        my ($self, %params) = @_;
        return $self->check_temp( $params{temperature} );
    }

    1;

Then, we can use the diagnostic as either an instance or class in
our health-check:

    # Register a class check.
    $health_check->register( 'HealthCheck::Diagnostic::TempCheck' );

    # Register an instance check.
    $diagnostic = HealthCheck::Diagnostic::WeatherCheck->new(
        now => 'sunny',
    );
    $health_check->register( $diagnostic );

    # Run the checks.
    $health_check->check( temperature => 100 );

Here are the results from that last C<check> call:

    {   status  => 'CRITICAL',
        results => [
            {
                status => 'CRITICAL',
                info   => 'The temperature is too hot',
            },
            {
                status => 'OK',
                info   => 'The weather is sunny',
            },
        ],
    }

=head2 More in-depth example

In this example, we're going to add a check for a physical system
to make it easier to visualize,
a sensor system that can tell us when we should open or close the window.
What we're going to imagine is that we have three sensors:
inside, outside, and the window status.
The inside sensor can tell us the current temperature,
while the outside sensor can tell us both temperature and whether it is raining.
The window sensor is just a boolean check for whether the window is open.


We might initialize a diagnostic with several different sensors
that let it decide whether our window is in a good position.

    my $diagnostic = HealthCheck::Diagnostic::WindowStatus->new(
        inside  => My::Sensor::Inside->new,
        outside => My::Sensor::Outside->new,
        window  => My::Sensor::Window->new,

        desired_min => 20,
        desired_max => 23,
    );


The implementation for that check might look something like this:

    package HealthCheck::Diagnostic::WindowStatus;
    use parent "HealthCheck::Diagnostic";
    use strict;
    use warnings;

    sub run {
        my ($self) = @_;

        # Gather some data that we can return to be used for graphing
        my @data = (
            {   label => "Inside Temperature",
                value => $self->{inside}->temp,
            },
            {   label => "Outside Temperature",
                value => $self->{outside}->temp,
            },
            {   label => "Currently Raining",
                value => $self->{outside}->is_raining,
            },
            {   label => "Window is Open",
                value => $self->{window}->is_open,
            },
        );

        my %res = ( status = "OK", data = \@data );

        # If it's currently raining, need to close the windows
        if ( $self->{outside}->is_raining ) {
            if ( $self->current_state eq "open" ) {
                $res{status} = "CRITICAL";
                $res{info}   = "Close the window, it's raining!";
            }
            return \%res;
        }

        # Otherwise, see if the state we want matches the current state.
        my $desired_state = $self->desired_state;
        if ( $desired_state ne $self->current_state ) {
            $res{status} = "WARNING";
            $res{info}   = "\u$desired_state the window!";
        }

        return \%res;
    }

    sub current_state { shift->{window}->is_open ? "open" : "close" }

    sub desired_state {
        my ($self) = @_;

        my $inside  = $self->{inside}->temp;
        my $outside = $self->{outside}->temp;

        # If the weather is nice outside, open the window
        if (    $outside >= $self->{desired_min}
            and $outside <= $self->{desired_max} )
        {
            return "open";
        }

        # If the outside temp is in the correct
        # direction of our desired temp, open the window.
        my $cold_inside    = $inside < $self->{desired_min};
        my $hot_inside     = $inside > $self->{desired_max};
        my $warmer_outside = $inside < $outside;
        my $cooler_outside = $inside > $outside;

        if (   ( $cold_inside and $warmer_outside )
            or ( $hot_inside  and $cooler_outside ) )
        {
            return "open";
        }

        return "close";
    }

    1;
