=head1 Writing a HealthCheck::Diagnostic

So, you need to check the health of something and are here to find out how.
Well, lets see what we can do to help you figure that out.

=head2 What is a HealthCheck Diagnostic?

A health check diagnostic is a subroutine that returns a hashref in the
L<Health Check Standard|https://support.grantstreet.com/wiki/display/AC/Health+Check+Standard>
format.
While this can be as simple as C<< sub { status => 'OK' } >>,
you're probably here because you want to be able to share a check with other
people, or write tests for the check, which are both great ideas that should be
encouraged.

The only requirement for a diagnostic is that it is callable
and that it returns a hashref (or sometimes even an even-sized list) that
includes a C<status> key and optionally some other optional keys.

=head2 Diagnostic methods

The L<HealthCheck::Diagnostic> module provides a base for writing your
own checks with validation of the results as a promise to conform
to the standard.
When you want to create your own diagnostic, you have the option to
override a few different methods.

=head3 new

This is your basic constructor method.
It just returns the blessed object, so you may want to add default
values on the diagnostic instance that is returned.

Set a default label on the diagnostic instance:

    sub new {
        my ($class, %params) = @_;

        return $class->SUPER::new(
            label => 'default_label',
            %params,
        );
    }

You may also want to allow the constructor to take in a hashref, or
an even-sized list of parameters:

    my %params = @params == 1 && ( ref $params[0] || '' ) eq 'HASH'
        ? %{ $params[0] } : @params;

=head3 run

This is your basic check. It runs the test, and returns the result hashref.
You would most-likely be overriding this method with your actual test
logic.

One special note to keep in mind is that any exceptions get trapped in
the C<info> key of the result hashref.

=head3 summarize

This performs some extra logic if you want to have sub-tests in your
diagnostic.
This method merely squashes those C<status> values in the sub-tests and
validates the result hashref for errors.

Here is an example of a C<run> override that utilizes summarize:

    sub run {
        my $test1 = {
            status => 'OK',
            info   => 'The test passed',
        };
        my $test2 = {
            status => 'CRITICAL',
            info   => 'The test failed',
        };

        return {
            info    => 'Uses summarize',
            results => [ $test1, $test2 ],
        };
    }

This is what the result hashref would look like when the check is run:

    {   status  => 'CRITICAL',
        info    => 'Uses summarize',
        results => [ $test1, $test2 ],
    }

Note that C<summarize> is called during the C<check> method, so you may
want to take that into account if you are overriding the C<check> method
in any way.

=head3 check

This is what gets called by the HealthCheck.
It ends up calling C<run> and then C<summarize> on the result hashref.
You would want to override this method if you want to roll out your
own custom approach, likely for validation and summarization.

One special note to keep in mind is that exceptions do not get trapped
in here at all, as opposed to C<run>.

You may want to require certain parameters to be passed to the check.
This type of validation is done as follows:

    sub check {
        my ($self, %params ) = @_;

        croak( "Missing required `file` key" )
            unless $params{file};

        my $res = $self->SUPER::check( %params );
        return $res;
    }

=head2 Writing class checks and instance checks

Now that you know about the methods, you may want to know about the
different ways to create your diagnostic.

=head3 Instance checks

Instance checks are diagnostics that are designed to be used as an
instance.
This implementation requires you to instantiate the diagnostic with
the parameters being used in the check.

Here is an example instance-only implementation module:

    package HealthCheck::Diagnostic::TempCheck;
    use base 'HealthCheck::Diagnostic';

    sub check_temp { .. } # Returns a hashref using $_[1] as temp value.

    sub run {
        my ($self, %params) = @_;
        return $self->check_temp( $self->{temperature} );
    };

    1;

Here is an example using that module:

    my $diagnostic = HealthCheck::Diagnostic::TempCheck->new(
        temperature => '22',
    );
    $health_check->register( $diagnostic );
    $health_check->check;

If we want to create an instance-only implementation, we may want
to override the C<check> method in our diagnostic module to put that
restriction in-place:

    sub check {
        my ($self, @args ) = @_;
        croak( "check cannot be called as a class method" )
            unless ref $self;
        return $self->SUPER::check( @args );
    }

=head3 Class checks

Class check diagnostics are designed so that the diagnostic does not
need to be an instance.
In that case, we pay special attention to the parameters that are
passed to the C<check> and C<run> methods.

Here is an example of the same diagnostic listed above, but uses a
class implementation:

    package HealthCheck::Diagnostic::TempCheck;
    use base 'HealthCheck::Diagnostic';

    sub check_temp { ... } # Returns a hashref using $_[1] as temp value.

    sub run {
        my ($self, %params) = @_;
        return $self->check_temp( $params{temperature} );
    }

    1;

Any parameters passed to C<check> are passed to C<run> by default.
Here is an example using that module in a health-check:

    $health_check->register( 'HealthCheck::Diagnostic::TempCheck' );
    $health_check->check( temperature => 20 );

=head3 Multi checks

In some cases where we would want to allow for both an instance and class
check, we can do that.
We just need to define our diagnostic so that it can handle that:

    package HealthCheck::Diagnostic::TempCheck;
    use base 'HealthCheck::Diagnostic';

    sub check_temp { ... } # Returns a hashref using $_[1] as temp value.

    sub check {
        my ($self, %params) = @_;
        if ( ref $self ) {
            # Copy over instance values as arguments to the `run` method.
            params{$_} = $self->{$_}
                foreach grep { ! defined $params{$_} } keys %$self;
        }
        return $self->SUPER::check( %params );
    }

    sub run {
        my ($self, %params) = @_;
        return $self->check_temp( $params{temperature} );
    }

    1;

Then, we can use the diagnostic as either an instance or class in
our health-check:

    # Register a class check.
    $health_check->register( 'HealthCheck::Diagnostic::TempCheck' );

    # Register an instance check.
    $diagnostic = HealthCheck::Diagnostic::WeatherCheck->new(
        now => 'sunny',
    );
    $health_check->register( $diagnostic );

    # Run the checks.
    $health_check->check( temperature => 100 );

Here are the results from that last C<check> call:

    {   status  => 'CRITICAL',
        results => [
            {
                status => 'CRITICAL',
                info   => 'The temperature is too hot',
            },
            {
                status => 'OK',
                info   => 'The weather is sunny',
            },
        ],
    }

=head2 How can I make my check testable and sharable?

The L<HealthCheck::Diagnostic> module provides a base for writing your
own checks with validation of the results as a promise to conform
to the standard.

=head3 A simple diagnostic

The basics of a check that does the same thing as above is as simple as:

    package HealthCheck::Diagnostic::Simple;
    use parent 'HealthCheck::Diagnostic';
    sub run { return { status => 'OK' } }
    1;

You can then use that as a check and have that return value validated:

    # As a class
    $health_check->register( 'HealthCheck::Diagnostic::Simple' );

    # As an object
    my $diagnostic = HealthCheck::Diagnostic::Simple->new(
        id    => "a_check",
        label => "A Simple Check",
        tags  => ['simple'],
    );
    $health_check->register($diagnostic);

When using it as an object, the parent class will automatically copy a
select set of the attributes from the C<$diagnostic> object to the result.
With the above set of checks registered, the results look something like:

    {   status  => "OK",
        results => [
            { status => "OK" },
            {   id     => "a_check",
                label  => "A Simple Check",
                status => "OK",
                tags   => ["simple"]
            },
        ],
    }

=head3 A more in depth example

In this example, we're going to add a check for a physical system
to make it easier to visualize,
a sensor system that can tell us when we should open or close the window.
What we're going to imagine is that we have three sensors:
inside, outside, and the window status.
The inside sensor can tell us the current temperature,
while the outside sensor can tell us both temperature and whether it is raining.
The window sensor is just a boolean check for whether the window is open.


We might initialize a diagnostic with several different sensors
that let it decide whether our window is in a good position.

    my $diagnostic = HealthCheck::Diagnostic::WindowStatus->new(
        inside  => My::Sensor::Inside->new,
        outside => My::Sensor::Outside->new,
        window  => My::Sensor::Window->new,

        desired_min => 20,
        desired_max => 23,
    );


The implementation for that check might look something like this:

    package HealthCheck::Diagnostic::WindowStatus;
    use parent "HealthCheck::Diagnostic";
    use strict;
    use warnings;

    sub run {
        my ($self) = @_;

        # Gather some data that we can return to be used for graphing
        my @data = (
            {   label => "Inside Temperature",
                value => $self->{inside}->temp,
            },
            {   label => "Outside Temperature",
                value => $self->{outside}->temp,
            },
            {   label => "Currently Raining",
                value => $self->{outside}->is_raining,
            },
            {   label => "Window is Open",
                value => $self->{window}->is_open,
            },
        );

        my %res = ( status = "OK", data = \@data );

        # If it's currently raining, need to close the windows
        if ( $self->{outside}->is_raining ) {
            if ( $self->current_state eq "open" ) {
                $res{status} = "CRITICAL";
                $res{info}   = "Close the window, it's raining!";
            }
            return \%res;
        }

        # Otherwise, see if the state we want matches the current state.
        my $desired_state = $self->desired_state;
        if ( $desired_state ne $self->current_state ) {
            $res{status} = "WARNING";
            $res{info}   = "\u$desired_state the window!";
        }

        return \%res;
    }

    sub current_state { shift->{window}->is_open ? "open" : "close" }

    sub desired_state {
        my ($self) = @_;

        my $inside  = $self->{inside}->temp;
        my $outside = $self->{outside}->temp;

        # If the weather is nice outside, open the window
        if (    $outside >= $self->{desired_min}
            and $outside <= $self->{desired_max} )
        {
            return "open";
        }

        # If the outside temp is in the correct
        # direction of our desired temp, open the window.
        my $cold_inside    = $inside < $self->{desired_min};
        my $hot_inside     = $inside > $self->{desired_max};
        my $warmer_outside = $inside < $outside;
        my $cooler_outside = $inside > $outside;

        if (   ( $cold_inside and $warmer_outside )
            or ( $hot_inside  and $cooler_outside ) )
        {
            return "open";
        }

        return "close";
    }

    1;


Going through this we can pick out some important features this check
implements,
like inheriting from L<HealthCheck::Diagnostic>
and defining a C<run> method.

Some things to notice about the C<run> method are that it relies on other
helper methods to make its decision about the state of the service and that
it returns a hashref with several keys in addition to the C<status>.
The L<info> is a human readable, short description of the result,
something that tells a person what's going on.
The C<data> key is a "machine readable output" of the check,
although the output is not well defined, one use is to be compatible with
the GSG
L<Status API|https://support.grantstreet.com/wiki/display/DEVOPS/Status+API>
specification, as this example shows.
